# Development Plan: User Onboarding & Location Setup

This document outlines the step-by-step plan to implement, test, and verify the User Onboarding and Location Setup feature.

## Phase 1: Core Logic and Data Layer

- [ ] **Step 1.1: Define Location Domain with Freezed**
  - [ ] Create a new file, `location_exceptions.freezed.dart`, which will be generated by the Freezed package.
  - [ ] Modify the existing `location_exceptions.dart` file to use the `@freezed` annotation. This will allow me to define the custom exception classes in a more concise and type-safe way.

- [ ] **Step 1.2: Implement Data Repositories with SharedPreferences**
  - [ ] Keep the `GeoLocatorRepository` as it is since it deals with the `geolocator` package, not local storage.
  - [ ] Update the `UserLocationRepository` to use `SharedPreferences` instead of `Sembast`. This will involve changing the implementation to store and retrieve the user's location data from `SharedPreferences`.

- [ ] **Step 1.3: Unit Test Repositories**
  - [ ] The unit tests for `GeoLocatorRepository` will remain the same.
  - [ ] Update the unit tests for `UserLocationRepository` to work with the new `SharedPreferences`-based implementation. This will likely involve using `SharedPreferences.setMockInitialValues` to mock the `SharedPreferences` data.
  - [ ] **All unit tests must pass before proceeding.**

## Phase 2: State Management and UI Logic

- [ ] **Step 2.1: Create Riverpod Controllers**
  - [ ] Implement `UserLocationController` to manage the state of the location being fetched (loading, data, error) and to orchestrate calls to the `GeoLocatorRepository`.
  - [ ] Implement `LocalUserLocationSaver` to handle the action of saving the chosen location via the `UserLocationRepository`.

- [ ] **Step 2.2: Unit Test Controllers**
  - [ ] Write unit tests for `UserLocationController`, mocking the `GeoLocatorRepository` to verify correct state transitions.
  - [ ] Write unit tests for `LocalUserLocationSaver`, mocking the `UserLocationRepository` to verify its interaction and state changes.
  - [ ] **All controller unit tests must pass before proceeding.**

## Phase 3: UI Implementation

- [ ] **Step 3.1: Build UI Components**
  - [ ] Create the main `StartupScreen` with a responsive layout that adapts to mobile and desktop sizes.
  - [ ] Build the `StartupContent` widget to display the welcome message and logo.
  - [ ] Build the `GetLocationContent` widget, which contains the location preview, "Get Current," and "From Map" buttons.
  - [ ] Implement the `PickLocationScreen` for the manual map-based location selection.
  - [ ] Create a `GoogleMapWidget` to display the map preview and the interactive map.

- [ ] **Step 3.2: Widget & Golden Tests**
  - [ ] Write widget tests for `StartupScreen` and `GetLocationContent` to verify UI elements are present and responsive.
  - [ ] Create golden image tests for the `StartupScreen` on both mobile and desktop sizes to ensure visual consistency.
  - [ ] **All widget and golden tests must pass before proceeding.**

## Phase 4: End-to-End Integration

- [ ] **Step 4.1: Connect UI to Controllers**
  - [ ] Wire up the buttons in `GetLocationContent` and `PickLocationScreen` to call the appropriate methods on the Riverpod controllers.
  - [ ] Use `AsyncValueWidget` and `ref.listen` to display loading indicators and handle error dialogs based on the state of the controllers.

- [ ] **Step 4.2: Implement Routing and Redirection**
  - [ ] Configure `go_router` to show `StartupScreen` as the initial route if no location is saved.
  - [ ] Implement the redirection logic to automatically navigate the user to the main app (`/`) after a location is successfully saved.

- [ ] **Step 4.3: Integration and E2E Testing**
  - [ ] Write integration tests that simulate the full user flow: launching the app, tapping "Get Started," fetching a location, saving it, and verifying the redirection to the home screen.
  - [ ] **All integration tests must pass before the feature is considered complete.**

## Phase 5: Code Review and Refinement

- [ ] **Step 5.1: Final Code Review**
  - [ ] Conduct a final review of all new code in the `startup` feature directory for clarity, consistency, and adherence to project standards.

- [ ] **Step 5.2: Documentation**
  - [ ] Ensure all public classes and complex methods have clear and concise documentation.
  - [ ] Update the main `PRD.md` if any requirements changed during implementation.